#####################
# Testie configuraton
#####################
%info
HTTP Load Balancer

The DUT needs two 40G interfaces, one facing WAN and the other LAN. The LAN side
will use 4 ips as source (10.200.[1-4].5) to send the requests to the HTTP server.


%config
timeout=60
var_names={LENGTH:Length,result-THROUGHPUT:Throughput,TXCPU:Transmit CPU,RXCPU:Receive CPU,FREQ:CPU frequency,C:Concurrent connections,BUILDER:Reconstruct batches of Flows,result-LATENCY:Average file download time,result-Receive rate:Receive rate,FSIZE:File size}
n_retry=1
acceptable=0.01
n_runs=3
var_serie=LENGTH
var_log={FSIZE,result-THROUGHPUT,result-LATENCY,result-Receive rate}
var_unit={result: ,result-LATENCY:ms,FSIZE:kbyte,result-THROUGHPUT:GBits/s,result-PPS:KPackets/s}
var_divider={result-THROUGHPUT:125000000,result-LINK:1000000000,result-LATENCY:0.001,result-PPS:1000} //Throughput is brought back to bits
var_format={result:%d,result-LATENCY:%d}
var_grid={result-LATENCY,result-THROUGHPUT}
var_lim={result-THROUGHPUT:0-5}
var_ticks={result-THROUGHPUT:0+1+2+4+10+20+40}
//graph_result_as_variables={LINK+THROUGHPUT:Receive rate}
//graph_variable_as_series={Receive rate}
//graph_combine_results={LINK+THROUGHPUT:Link rate+Payload rate}
graph_subplot_result={THROUGHPUT+PPS:rate}

%variables
BLOCKING=false
FREQ=2400000
none:PATH=
C=[1*128]
C=128
FSIZE=[0*1048576]
//FSIZE=[1*32768]
th=4
full:th=[1*16]
//NC=2
NC=1
tunemiddle:BUILDER={0,1}
BUILDER=1
AGGCACHE=1
CACHESIZE=65536
NODUT=0
NGINX_ROOT=/tmp/nginx/
NGINX_PORT=80
GEN_TIME=5

tunemiddle:BUILDER={0,1}
tunemiddle:AGGCACHE={0,1}
tunemiddle:CACHESIZE=[1024*65536]
tunemiddle:FSIZE={8,32,1024}

haproxy:MAXCONN=200000
haproxy:BALANCE=static-rr
haproxy:SOMAXCONN=200000
haproxy:SYNBACKLOG=200000
tunehaproxy:MAXCONN={128,1024,32768,200000}
tunehaproxy:BALANCE={roundrobin,static-rr}
tunehaproxy:FSIZE={8,32,1024}

%middleclick:require
test "$AGGCACHE" -eq "0" -o "$CACHESIZE" -eq "65536"

%init autokill=false
sleep 8 //Wait for some time that interfaces goes ready etc
echo "RESULT 1"

%haproxy:import@client wait_ping NIC=0 delay=4
%haproxy:import@server wait_ping NIC=1 delay=4

%init@server
set -eu
mkdir -p ${NGINX_ROOT}

touch ${NGINX_ROOT}/bin-0K
n=1
while [ $n -le 1048576 ] ; do
    if [ ! -e ${NGINX_ROOT}/bin-${n}K ] ; then
        dd if=/dev/urandom of=${NGINX_ROOT}/bin-${n}K bs=1K count=$n
    fi
    n=$(echo "$n*2" | bc)
done
echo "RESULT 1"

%require
test $C -ge $th

%-webgen,-wrk:require
echo "You must provide a generator method !"
exit 1

%late_variables
FILE_PATH=EXPAND(bin-${FSIZE}K)

%haproxy:import@dut dev_channels NIC=0 N=1 delay=2
%haproxy:import@dut dev_channels NIC=1 N=1 delay=2
%wrk:import@client dev_rate NIC=0 delay=2
%import@server nginx

//WRK gen method
%wrk:import@client wrk HTTP_PORT=80 delay=5

//Click webgen method
%webgen:script@client deps=middleclick sudo=true delay=2
click --dpdk -c 1 -n 4 -- webgen.click

%webgen:file@client webgen.click
TSCClock
arpq :: ARPQuerier(${self:0:ip}, ${self:0:mac});

wb :: WebGen(PREFIX 10.200.0.0/16, DST 10.200.0.5, RATE 100000); //, LIMIT -1, ACTIVE true)
-> arpq
-> td :: ToDPDKDevice(${self:0:pci});

fd :: FromDPDKDevice(${self:0:pci}, PROMISC false)
    -> c0 :: Classifier(12/0806 20/0001,
                        12/0806 20/0002,
                        12/0800)[2]
    -> Strip(14)
    -> CheckIPHeader(CHECKSUM false)
    -> IPClassifier(tcp && dst port 80)
    -> avg :: AverageCounter
    -> wb;

    c0[0] -> ARPResponder(10.200.0.1 ${self:0:mac})
          -> td;
    c0[1] -> [1]arpq;

DriverManager(
    wait 1s,
    write avg.reset,
    wait 4s,
    print "RESULT-THROUGHPUT $(avg.link_rate)",
    stop
)

%wrk:import@client dpdk-bind DRIVER=i40e NIC=0
%webgen:import@client dpdk-bind NIC=0
%-quadsrv:import@server dpdk-bind DRIVER=i40e NIC=1

%quadsrv:import@server dpdk-bind DRIVER=i40e NIC=0
%quadsrv:import@server dpdk-bind DRIVER=i40e NIC=1
%quadsrv:import@server dpdk-bind DRIVER=i40e NIC=2
%quadsrv:import@server dpdk-bind DRIVER=i40e NIC=3
%haproxy:import@dut dpdk-bind DRIVER=i40e NIC=0
%haproxy:import@dut dpdk-bind DRIVER=i40e NIC=1 delay=1
%middleclick:import@dut dpdk-bind NIC=0
%middleclick:import@dut dpdk-bind NIC=1 delay=1


//Common ips for dut
%script@dut autokill=false 0:ip=10.200.0.1 1:ip=10.100.1.1

//Quadsrv is used when the server is another computer with 4 links
%-quadsrv:init@server sudo=true autokill=false 1:ip=10.100.1.2 delay=2
sudo sysctl -w net.core.somaxconn=262144
sudo sysctl -w net.ipv4.tcp_max_syn_backlog=3240000
sudo ifconfig ${server:1:ifname} ${server:1:ip} netmask 255.255.255.0
sudo ifconfig ${server:1:ifname} up
sudo ip addr add 10.100.1.1/24 dev ${server:1:ifname}
sudo ip addr add 10.100.2.1/24 dev ${server:1:ifname}
sudo ip addr add 10.100.3.1/24 dev ${server:1:ifname}
sudo ip addr add 10.100.4.1/24 dev ${server:1:ifname}
sudo iptables -X
sudo iptables -F
sudo iptables -F -t nat
echo "RESULT 1"

%quadsrv:init@server sudo=true autokill=false 0:ip=10.100.1.1 1:ip=10.100.2.1 2:ip=10.100.3.1 3:ip=10.100.4.1 delay=2
sudo sysctl -w net.core.somaxconn=262144
sudo sysctl -w net.ipv4.tcp_max_syn_backlog=3240000
sudo ifconfig ${server:0:ifname} ${server:0:ip} netmask 255.255.255.0
sudo ifconfig ${server:0:ifname} up
sudo ifconfig ${server:1:ifname} ${server:1:ip} netmask 255.255.255.0
sudo ifconfig ${server:1:ifname} up
sudo ifconfig ${server:2:ifname} ${server:2:ip} netmask 255.255.255.0
sudo ifconfig ${server:2:ifname} up
sudo ifconfig ${server:3:ifname} ${server:3:ip} netmask 255.255.255.0
sudo ifconfig ${server:3:ifname} up
//sudo ip addr add 10.100.0.1/24 dev ${server:0:ifname}
sudo iptables -X
sudo iptables -F
sudo iptables -F -t nat
echo "RESULT 1"



%init@client sudo=true autokill=false 0:ip=10.200.0.5 delay=2
sudo ifconfig ${client:0:ifname} 10.200.0.5 netmask 255.255.255.0
sudo ifconfig ${client:0:ifname} up
sudo ip route del 10.200.0.0/24 dev ens6f0
sudo ip route add 10.200.0.5/32 dev ens6f0
sudo ip route add 10.200.0.0/16 via 10.200.0.5 dev ens6f0
sudo iptables -X
sudo iptables -F
sudo iptables -F -t nat
sudo sysctl -w net.core.somaxconn=262144
sudo sysctl -w net.ipv4.tcp_max_syn_backlog=3240000
echo "RESULT 1"



//#############################
%middleclick:script@dut sudo=true  0:ip=10.200.0.1 1:ip=10.100.1.1
click --dpdk -n 4 -l 0-$(( $NC -1 )) -- CONF BUILDER=$BUILDER AGGCACHE=$AGGCACHE CACHESIZE=$CACHESIZE

%file@dut CONF
define($IP1 10.200.0.1)
define($MAC1 ${dut:0:mac})
define($NET1  10.200.0.0/16)
define($RANGE1  10.200.0.0/30)
define($HOST $RANGE1)

define($IP2 10.100.0.1)
define($MAC2 ${dut:1:mac})
define($NET2  10.100.0.0/16)

define($SERVERIP1 10.100.1.1)
define($SERVERIP2 10.100.2.1)
define($SERVERIP3 10.100.3.1)
define($SERVERIP4 10.100.4.1)

define($SIP1 10.100.1.2)
define($SIP2 10.100.2.2)
define($SIP3 10.100.3.2)
define($SIP4 10.100.4.2)

//Parameters
define($rxverbose 99)
define($txverbose 99)
define($bout 32)
define($ignore 0)

elementclass ARPDispatcher {
        input[0]->
		iparp :: FlowDispatcher(
                        12/0800,
                        12/0806,
                        -)
		iparp[0] -> [0]output
		iparp[1] -> arptype ::FlowDispatcher(20/0001, 20/0002, -)
		iparp[2] -> [3]output

		arptype[0] -> [1]output
		arptype[1] -> [2]output
		arptype[2] -> [3]output
}


elementclass Receiver { $port, $mac, $ip, $range |

    input[0]
//    -> Print("ARP QUERIER FROM $mac",-1)
    -> arpq :: ARPQuerier($ip, $mac)
//    -> Print("$mac OUT", -1)
    -> etherOUT :: Null

    f :: FromDPDKDevice($port, VERBOSE $rxverbose, PROMISC false, RSS_AGGREGATE $AGGCACHE)
//    -> Print("FROM $mac",-1)
    -> FlowClassifier(BUILDER $BUILDER, AGGCACHE $AGGCACHE, CACHESIZE $CACHESIZE,VERBOSE 0)
//    -> stats :: BatchStats()
    -> arpr :: ARPDispatcher()

    arpr[0]
    -> FlowStrip(14)
//    -> Print("IP")
    -> receivercheck :: CheckIPHeader(CHECKSUM false)
    -> inc :: FlowDispatcher(9/01, 9/06, -)

    inc[0]
    -> Print("ICMP")
    -> icmptype :: FlowDispatcher(20/08, -)
//    -> Print("ICMP echo")
    -> ICMPPingResponder
    -> arpq


    icmptype[1] -> Print("Unhandled ICMP", -1) -> Discard

    inc[1]
//    -> Print("TCP", -1)
    -> [0]output;


	inc[2]
    -> Unstrip(14)
//	-> Print("NON TCP or ICMP",-1)
	-> Discard

    arpr[1]
    -> Print("RX ARP Request $mac", -1)
    -> arpRespIN :: ARPResponder($range $mac)
    -> Print("TX ARP Responding", -1)
    -> etherOUT;

    arpRespIN[1] -> Print("ARP Packet not for $mac") -> Discard

    arpr[2]
    -> Print("RX ARP Response $mac", -1)
    -> [1]arpq;

    arpr[3] -> Print("Unknown packet type IN???",-1) -> Discard();


    etherOUT
//    -> avgIN :: AverageCounter(IGNORE $ignore)
    -> t :: ToDPDKDevice($port,BLOCKING true,BURST $bout, VERBOSE $txverbose)
}

ipOUT :: LookupIPRouteMP($NET1 0,
                    $NET2 1,
                    $HOST 2)

lb :: FlowIPLoadBalancer($SERVERIP1,$SERVERIP2,$SERVERIP3,$SERVERIP4, SIP $SIP1 $SIP2 $SIP3 $SIP4 )

r1 :: Receiver(${dut:0:pci},$MAC1,$IP1,$RANGE1) [0] -> ipOUT
//r1[1] -> ipOUT

r2 :: Receiver(${dut:1:pci},$MAC2,$IP2,$IP2 $SIP1 $SIP2 $SIP3 $SIP4) [0]
  -> FlowDispatcher(9/06)
  -> FlowDispatcher(20/0050)
//  -> IPPrint(REVERSELB)
  -> FlowIPLoadBalancerReverse(lb)
//  -> IPPrint(REVERSELBOUT)
//  -> CheckIPHeader(CHECKSUM false)
  -> [0]r1

//r2[1] -> ipOUT

ipOUT[0]
//-> Print("CLIENTS")
-> [0]r1

ipOUT[1]
//-> Print("SERVER")
-> [0]r2

ipOUT[2]
//-> Print("HOST", -1)
-> istcp :: FlowDispatcher(9/06, -)
-> FlowDispatcher(22/0050)
//-> IPPrint("LB")
-> lb
//-> IPPrint("LBOUT")
//->CheckIPHeader(CHECKSUM false)
-> [0]r2

istcp[1] -> Print("NON TCP packet to LB !") -> Discard

Script(TYPE ACTIVE,
                print "Waiting for link initialization...",
                wait 2s,
                print "Ready")

DriverManager(
                pause,
                print "Server finished. Waiting for last packets...",
                wait $(wait),
                print "Rate : ",
                print "$(r1/avgIN.link_rate)",
                print "$(r2/avgIN.link_rate)",
                print "Count :",
                print "$(r1/avgIN.count)/$(r1/f.count)",
                print "$(r2/avgIN.count)/$(r2/f.count)",
                print "Dropped : ",
                print "$(r1/f.dropped) $(r1/t.dropped)",
                print "$(r2/f.dropped) $(r2/t.dropped)",
                print "$(r1/arpq.drops) $(r2/arpq.drops)",
                print "$(r1/stats.average) $(r1/stats.median)",
                print "$(r2/stats.average) $(r2/stats.median)",
                stop);

//#############################
%haproxy:init@dut sudo=true delay=1
sudo sysctl -w net.core.somaxconn=$SOMAXCONN
sudo sysctl -w net.ipv4.tcp_max_syn_backlog=$SYNBACKLOG

sudo service fail2ban stop


RXQUEUE=$NC
ethA=${dut:0:ifname}
ethB=${dut:1:ifname}

echo 1 > /proc/sys/net/ipv4/ip_forward
1
sleep 1

ethtool -L $ethA combined $RXQUEUE
ethtool -L $ethB combined $RXQUEUE

sudo ifconfig $ethA 10.200.0.1 netmask 255.255.0.0
sudo ifconfig $ethA up

sudo ip addr add 10.200.0.1/24 dev $ethA
sudo ip addr add 10.200.0.2/24 dev $ethA
sudo ip addr add 10.200.0.3/24 dev $ethA
sudo ip addr add 10.200.0.4/24 dev $ethA

sudo ifconfig $ethB 10.100.0.1 netmask 255.255.255.0
sudo ifconfig $ethB up
sudo ip addr add 10.100.1.2/24 dev $ethB
sudo ip addr add 10.100.2.2/24 dev $ethB
sudo ip addr add 10.100.3.2/24 dev $ethB
sudo ip addr add 10.100.4.2/24 dev $ethB

echo "RESULT 1"

%haproxy:script@dut sudo=true

sudo killall -9 haproxy &> /dev/null

#sudo /home/tom/set_irq_affinity.sh $ethA $ethB
#sudo ethtool -K $ethA tso off
#sudo ethtool -K $ethA lro off
#sudo ethtool -K $ethA gso off
#sudo ethtool -K $ethA gro off
#sudo ethtool -K $ethB tso off
#sudo ethtool -K $ethB lro off
#sudo ethtool -K $ethB gso off
#sudo ethtool -K $ethB gro off


echo "Launching HA"
if [ "$NC" -eq 1 ] ; then
    sudo /home/tom/set_irq_affinity.sh $ethA $ethB
    M="0"
else
    M="0,1"
    sudo /home/tom/set_irq_affinityseq.sh $ethA $ethB
fi

taskset -c $M haproxy -db -f haproxy.cfg
echo "HAProxy finished"
killall -9 haproxy &> /dev/null

%haproxy:file@dut haproxy.cfg
global
	daemon
    nbproc $NC
    maxconn $MAXCONN


defaults
	mode tcp
	timeout connect 5000
	timeout client  50000
	timeout server  50000
    option dontlog-normal

frontend nodes
	bind *:80
	default_backend nodes


backend nodes
	balance $BALANCE
    server web0 10.100.1.1
    server web1 10.100.2.1
    server web2 10.100.3.1
    server web3 10.100.4.1
